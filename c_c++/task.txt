
任务调度设计

线程部分
1. 调度线程1个
2. 处理线程若干个

数据部分
1. 持久化部分-数据库
2. 内存数据结构-任务队列-list/vector/queue

调度设计
1. 调度线程从数据库读取任务，读取出来的任务打上标识，防止一个任务被反复读取出来
   任务读取出来后，放到内存任务队列中
2. 处理线程 从内存任务队列获取任务
   1) 读取的任务 从任务队列删除 防止多个执行线程执行同一个任务
   2) 读取的任务 还保留在任务队列中，读取出来时，需要设置标识，防止其他线程执行同一个任务

任务执行完成，更新数据库设计
1. 处理线程 任务执行完成，直接更新数据库任务状态，同时更新任务队列任务状态
2. 处理线程 任务执行完成，更新内存中任务状态，由调度线程更新数据库，同时维护任务队列状态
3. 在极端的情况，如果任务执行完成后处理比较费时，可以新开一个任务完成处理线程，防止在调度线程中处理，影响新任务调度。

其他：
1. 任务调度线程 控制内存中任务个数
   需要考虑任务被处理线程获取时，任务是否还在任务队列中。总之，控制内存中任务个数包括 等待处理的 + 处理中的
2. 线程退出机制
   统一由调度线程，判断任务是否执行完成: 数据库中没有待执行的任务，内存任务队列为空。 完成后，设置退出标志位
   处理线程根据该标志位 退出
3. 调度线程 任务调度时，尽量在调度线程中完成任务的预处理工作
   如果预处理工作比较耗时，也不应该直接放到调度线程中，比如计算文件hash比较费时，需要新开线程处理后，再调度。
4. 对于比较消耗内存的任务，需要使用内存缓存池
5. 如果任务涉及java后台，通信协议数据包尽量基于流方式实现，java内存申请释放对于长时间运行的服务是个考验。
6. 数据传输可以考虑压缩，解压。 
